<html>
<head>
<title> Deducing this
</title>
<style type="text/css">html {
	position: relative;
	max-width: 1024px;
	height: 100%;
}
body {
	font-family: Helvetica, arial, sans-serif;
	font-size: 14px;
	line-height: 1.6;
	padding-top: 10px;
	padding-bottom: 10px;
	background-color: white;
	padding: 30px;
}
body>*:first-child {
	margin-top: 0 !important;
}
body>*:last-child {
	margin-bottom: 0 !important;
}
a {
	color: #4183C4;
}
a.absent {
	color: #cc0000;
}
a.anchor {
	display: block;
	padding-left: 30px;
	margin-left: -30px;
	cursor: pointer;
	position: absolute;
	top: 0;
	left: 0;
	bottom: 0;
}
h1, h2, h3, h4, h5, h6 {
	margin: 20px 0 10px;
	padding: 0;
	font-weight: bold;
	-webkit-font-smoothing: antialiased;
	cursor: text;
	position: relative;
}
h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor {
	background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA09pVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoMTMuMCAyMDEyMDMwNS5tLjQxNSAyMDEyLzAzLzA1OjIxOjAwOjAwKSAgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OUM2NjlDQjI4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OUM2NjlDQjM4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo5QzY2OUNCMDg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo5QzY2OUNCMTg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PsQhXeAAAABfSURBVHjaYvz//z8DJYCRUgMYQAbAMBQIAvEqkBQWXI6sHqwHiwG70TTBxGaiWwjCTGgOUgJiF1J8wMRAIUA34B4Q76HUBelAfJYSA0CuMIEaRP8wGIkGMA54bgQIMACAmkXJi0hKJQAAAABJRU5ErkJggg==) no-repeat 10px center;
	text-decoration: none;
}
h1 tt, h1 code {
	font-size: inherit;
}
h2 tt, h2 code {
	font-size: inherit;
}
h3 tt, h3 code {
	font-size: inherit;
}
h4 tt, h4 code {
	font-size: inherit;
}
h5 tt, h5 code {
	font-size: inherit;
}
h6 tt, h6 code {
	font-size: inherit;
}
h1 {
	font-size: 28px;
	color: black;
}
h2 {
	font-size: 24px;
	border-bottom: 1px solid #cccccc;
	color: black;
}
h3 {
	font-size: 18px;
}
h4 {
	font-size: 16px;
}
h5 {
	font-size: 14px;
}
h6 {
	color: #777777;
	font-size: 14px;
}
p, blockquote, ol, dl, li, table, pre {
	margin: 15px 0;
}
hr {
	background: transparent url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC) repeat-x 0 0;
	border: 0 none;
	color: #cccccc;
	height: 4px;
	padding: 0;
}
body>h2:first-child {
	margin-top: 0;
	padding-top: 0;
}
body>h1:first-child {
	margin-top: 0;
	padding-top: 0;
}
body>h1:first-child+h2 {
	margin-top: 0;
	padding-top: 0;
}
body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
	margin-top: 0;
	padding-top: 0;
}
a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
	margin-top: 0;
	padding-top: 0;
}
h1 p, h2 p, h3 p, h4 p, h5 p, h6 p {
	margin-top: 0;
}
li p.first {
	display: inline-block;
}
li {
	margin: 0;
}
ol {
	padding-left: 30px;
    margin: 5px;
    counter-reset: item;
}
ol > li {
    counter-increment: item;
}
ol ol > li {
    display: block;
}
ol ol > li:before {
    content: counters(item, ".") ". ";
    margin-left: -30px;
}
ul :first-child, ol :first-child {
	margin-top: 0;
}
ul ul { 
    margin-left: -15px;
}
dl {
	padding: 0;
}
dl dt {
	font-size: 14px;
	font-weight: bold;
	font-style: italic;
	padding: 0;
	margin: 15px 0 5px;
}
dl dt:first-child {
	padding: 0;
}
dl dt> :first-child {
	margin-top: 0;
}
dl dt> :last-child {
	margin-bottom: 0;
}
dl dd {
	margin: 0 0 15px;
	padding: 0 15px;
}
dl dd> :first-child {
	margin-top: 0;
}
dl dd> :last-child {
	margin-bottom: 0;
}
blockquote {
	border-left: 4px solid #dddddd;
	padding: 0 15px;
	color: #777777;
}
blockquote> :first-child {
	margin-top: 0;
}
blockquote> :last-child {
	margin-bottom: 0;
}
table {
	padding: 0;
	border-collapse: collapse;
}
table tr {
	border-top: 1px solid #cccccc;
	background-color: white;
	margin: 0;
	padding: 0;
}
table tr:nth-child(2n) {
	background-color: #f8f8f8;
}
table tr th {
	font-weight: bold;
	border: 1px solid #cccccc;
	margin: 0;
	padding: 6px 13px;
}
table tr td {
	border: 1px solid #cccccc;
	margin: 0;
	padding: 6px 13px;
}
table tr th :first-child, table tr td :first-child {
	margin-top: 0;
}
table tr th :last-child, table tr td :last-child {
	margin-bottom: 0;
}
td {
	vertical-align: top;
}
img {
	max-width: 100%;
}
span.frame {
	display: block;
	overflow: hidden;
}
span.frame>span {
	border: 1px solid #dddddd;
	display: block;
	float: left;
	overflow: hidden;
	margin: 13px 0 0;
	padding: 7px;
	width: auto;
}
span.frame span img {
	display: block;
	float: left;
}
span.frame span span {
	clear: both;
	color: #333333;
	display: block;
	padding: 5px 0 0;
}
span.align-center {
	display: block;
	overflow: hidden;
	clear: both;
}
span.align-center>span {
	display: block;
	overflow: hidden;
	margin: 13px auto 0;
	text-align: center;
}
span.align-center span img {
	margin: 0 auto;
	text-align: center;
}
span.align-right {
	display: block;
	overflow: hidden;
	clear: both;
}
span.align-right>span {
	display: block;
	overflow: hidden;
	margin: 13px 0 0;
	text-align: right;
}
span.align-right span img {
	margin: 0;
	text-align: right;
}
span.float-left {
	display: block;
	margin-right: 13px;
	overflow: hidden;
	float: left;
}
span.float-left span {
	margin: 13px 0 0;
}
span.float-right {
	display: block;
	margin-left: 13px;
	overflow: hidden;
	float: right;
}
span.float-right>span {
	display: block;
	overflow: hidden;
	margin: 13px auto 0;
	text-align: right;
}
code, tt {
	margin: 0 2px;
	padding: 0 5px;
	white-space: nowrap;
	border: 1px solid #eaeaea;
	background-color: #f8f8f8;
	border-radius: 3px;
}
pre code {
	margin: 0;
	padding: 0;
	white-space: pre;
	border: none;
	background: transparent;
}
.highlight pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	font-size: 13px;
	line-height: 19px;
	overflow: auto;
	padding: 6px 10px;
	border-radius: 3px;
}
pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	font-size: 13px;
	line-height: 19px;
	overflow: auto;
	padding: 6px 10px;
	border-radius: 3px;
}
pre code, pre tt {
	background-color: transparent;
	border: none;
}
sup {
	font-size: 0.83em;
	vertical-align: super;
	line-height: 0;
}
kbd {
	display: inline-block;
	padding: 3px 5px;
	font-size: 11px;
	line-height: 10px;
	color: #555;
	vertical-align: middle;
	background-color: #fcfcfc;
	border: solid 1px #ccc;
	border-bottom-color: #bbb;
	border-radius: 3px;
	box-shadow: inset 0 -1px 0 #bbb
}
* {
	-webkit-print-color-adjust: exact;
}
ins {
	color: #00A000
}
del {
	color: #A00000
}
</style><style type="text/css">
/**
	* prism.js default theme for JavaScript, CSS and HTML
	* Based on dabblet (http://dabblet.com)
	* @author Lea Verou
	*/

code[class*="language-"], pre[class*="language-"] {
	color: black;
	background: none;
	text-shadow: 0 1px white;
	font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
	font-size: 11px;
	text-align: left;
	white-space: pre;
	word-spacing: normal;
	word-break: normal;
	word-wrap: normal;
	line-height: 1.5;
	-moz-tab-size: 4;
	-o-tab-size: 4;
	tab-size: 4;
	-webkit-hyphens: none;
	-moz-hyphens: none;
	-ms-hyphens: none;
	hyphens: none;
}
pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection, code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
	text-shadow: none;
	background: #b3d4fc;
}
pre[class*="language-"]::selection, pre[class*="language-"] ::selection, code[class*="language-"]::selection, code[class*="language-"] ::selection {
	text-shadow: none;
	background: #b3d4fc;
}
@media print {
	code[class*="language-"], pre[class*="language-"] {
		text-shadow: none;
	}
}

/* Code blocks */

pre[class*="language-"] {
	padding: 1em;
	margin: .5em 0;
	overflow: auto;
}
:not(pre)>code[class*="language-"], pre[class*="language-"] {
	background: #f8f8f8;
}

/* Inline code */

:not(pre)>code[class*="language-"] {
	padding: .1em;
	border-radius: .3em;
	white-space: normal;
}
.token.comment, .token.prolog, .token.doctype, .token.cdata {
	color: slategray;
}
.token.punctuation {
	color: #999;
}
.namespace {
	opacity: .7;
}
.token.property, .token.tag, .token.boolean, .token.number, .token.constant, .token.symbol, .token.deleted {
	color: #905;
}
.token.selector, .token.attr-name, .token.string, .token.char, .token.builtin, .token.inserted {
	color: #690;
}
.token.operator {
	color: #a67f59;
}
.token.entity, .token.url, .language-css .token.string, .style .token.string {
	color: #a67f59;
	background: hsla(0, 0%, 100%, .5);
}
.token.atrule, .token.attr-value, .token.keyword {
	color: #07a;
}
.token.function {
	color: #DD4A68;
}
.token.regex, .token.important, .token.variable {
	color: #e90;
}
.token.important, .token.bold {
	font-weight: bold;
}
.token.italic {
	font-style: italic;
}
.token.entity {
	cursor: help;
}
</style>

<script type="text/javascript">
var _self="undefined"!=typeof window?window:"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope?self:{},Prism=function(){var e=/\blang(?:uage)?-(\w+)\b/i,t=0,n=_self.Prism={util:{encode:function(e){return e instanceof a?new a(e.type,n.util.encode(e.content),e.alias):"Array"===n.util.type(e)?e.map(n.util.encode):e.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/\u00a0/g," ")},type:function(e){return Object.prototype.toString.call(e).match(/\[object (\w+)\]/)[1]},objId:function(e){return e.__id||Object.defineProperty(e,"__id",{value:++t}),e.__id},clone:function(e){var t=n.util.type(e);switch(t){case"Object":var a={};for(var r in e)e.hasOwnProperty(r)&&(a[r]=n.util.clone(e[r]));return a;case"Array":return e.map&&e.map(function(e){return n.util.clone(e)})}return e}},languages:{extend:function(e,t){var a=n.util.clone(n.languages[e]);for(var r in t)a[r]=t[r];return a},insertBefore:function(e,t,a,r){r=r||n.languages;var l=r[e];if(2==arguments.length){a=arguments[1];for(var i in a)a.hasOwnProperty(i)&&(l[i]=a[i]);return l}var o={};for(var s in l)if(l.hasOwnProperty(s)){if(s==t)for(var i in a)a.hasOwnProperty(i)&&(o[i]=a[i]);o[s]=l[s]}return n.languages.DFS(n.languages,function(t,n){n===r[e]&&t!=e&&(this[t]=o)}),r[e]=o},DFS:function(e,t,a,r){r=r||{};for(var l in e)e.hasOwnProperty(l)&&(t.call(e,l,e[l],a||l),"Object"!==n.util.type(e[l])||r[n.util.objId(e[l])]?"Array"!==n.util.type(e[l])||r[n.util.objId(e[l])]||(r[n.util.objId(e[l])]=!0,n.languages.DFS(e[l],t,l,r)):(r[n.util.objId(e[l])]=!0,n.languages.DFS(e[l],t,null,r)))}},plugins:{},highlightAll:function(e,t){var a={callback:t,selector:'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'};n.hooks.run("before-highlightall",a);for(var r,l=a.elements||document.querySelectorAll(a.selector),i=0;r=l[i++];)n.highlightElement(r,e===!0,a.callback)},highlightElement:function(t,a,r){for(var l,i,o=t;o&&!e.test(o.className);)o=o.parentNode;o&&(l=(o.className.match(e)||[,""])[1],i=n.languages[l]),t.className=t.className.replace(e,"").replace(/\s+/g," ")+" language-"+l,o=t.parentNode,/pre/i.test(o.nodeName)&&(o.className=o.className.replace(e,"").replace(/\s+/g," ")+" language-"+l);var s=t.textContent,u={element:t,language:l,grammar:i,code:s};if(!s||!i)return n.hooks.run("complete",u),void 0;if(n.hooks.run("before-highlight",u),a&&_self.Worker){var c=new Worker(n.filename);c.onmessage=function(e){u.highlightedCode=e.data,n.hooks.run("before-insert",u),u.element.innerHTML=u.highlightedCode,r&&r.call(u.element),n.hooks.run("after-highlight",u),n.hooks.run("complete",u)},c.postMessage(JSON.stringify({language:u.language,code:u.code,immediateClose:!0}))}else u.highlightedCode=n.highlight(u.code,u.grammar,u.language),n.hooks.run("before-insert",u),u.element.innerHTML=u.highlightedCode,r&&r.call(t),n.hooks.run("after-highlight",u),n.hooks.run("complete",u)},highlight:function(e,t,r){var l=n.tokenize(e,t);return a.stringify(n.util.encode(l),r)},tokenize:function(e,t){var a=n.Token,r=[e],l=t.rest;if(l){for(var i in l)t[i]=l[i];delete t.rest}e:for(var i in t)if(t.hasOwnProperty(i)&&t[i]){var o=t[i];o="Array"===n.util.type(o)?o:[o];for(var s=0;s<o.length;++s){var u=o[s],c=u.inside,g=!!u.lookbehind,h=!!u.greedy,f=0,d=u.alias;u=u.pattern||u;for(var p=0;p<r.length;p++){var m=r[p];if(r.length>e.length)break e;if(!(m instanceof a)){u.lastIndex=0;var y=u.exec(m),v=1;if(!y&&h&&p!=r.length-1){var b=r[p+1].matchedStr||r[p+1],k=m+b;if(p<r.length-2&&(k+=r[p+2].matchedStr||r[p+2]),u.lastIndex=0,y=u.exec(k),!y)continue;var w=y.index+(g?y[1].length:0);if(w>=m.length)continue;var _=y.index+y[0].length,P=m.length+b.length;if(v=3,P>=_){if(r[p+1].greedy)continue;v=2,k=k.slice(0,P)}m=k}if(y){g&&(f=y[1].length);var w=y.index+f,y=y[0].slice(f),_=w+y.length,S=m.slice(0,w),O=m.slice(_),j=[p,v];S&&j.push(S);var A=new a(i,c?n.tokenize(y,c):y,d,y,h);j.push(A),O&&j.push(O),Array.prototype.splice.apply(r,j)}}}}}return r},hooks:{all:{},add:function(e,t){var a=n.hooks.all;a[e]=a[e]||[],a[e].push(t)},run:function(e,t){var a=n.hooks.all[e];if(a&&a.length)for(var r,l=0;r=a[l++];)r(t)}}},a=n.Token=function(e,t,n,a,r){this.type=e,this.content=t,this.alias=n,this.matchedStr=a||null,this.greedy=!!r};if(a.stringify=function(e,t,r){if("string"==typeof e)return e;if("Array"===n.util.type(e))return e.map(function(n){return a.stringify(n,t,e)}).join("");var l={type:e.type,content:a.stringify(e.content,t,r),tag:"span",classes:["token",e.type],attributes:{},language:t,parent:r};if("comment"==l.type&&(l.attributes.spellcheck="true"),e.alias){var i="Array"===n.util.type(e.alias)?e.alias:[e.alias];Array.prototype.push.apply(l.classes,i)}n.hooks.run("wrap",l);var o="";for(var s in l.attributes)o+=(o?" ":"")+s+'="'+(l.attributes[s]||"")+'"';return"<"+l.tag+' class="'+l.classes.join(" ")+'" '+o+">"+l.content+"</"+l.tag+">"},!_self.document)return _self.addEventListener?(_self.addEventListener("message",function(e){var t=JSON.parse(e.data),a=t.language,r=t.code,l=t.immediateClose;_self.postMessage(n.highlight(r,n.languages[a],a)),l&&_self.close()},!1),_self.Prism):_self.Prism;var r=document.currentScript||[].slice.call(document.getElementsByTagName("script")).pop();return r&&(n.filename=r.src,document.addEventListener&&!r.hasAttribute("data-manual")&&document.addEventListener("DOMContentLoaded",n.highlightAll)),_self.Prism}();"undefined"!=typeof module&&module.exports&&(module.exports=Prism),"undefined"!=typeof global&&(global.Prism=Prism);
</script>

<script type="text/javascript">
Prism.languages.clike={comment:[{pattern:/(^|[^\\])\/\*[\w\W]*?\*\//,lookbehind:!0},{pattern:/(^|[^\\:])\/\/.*/,lookbehind:!0}],string:{pattern:/(["'])(\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,greedy:!0},"class-name":{pattern:/((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[a-z0-9_\.\\]+/i,lookbehind:!0,inside:{punctuation:/(\.|\\)/}},keyword:/\b(if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,"boolean":/\b(true|false)\b/,"function":/[a-z0-9_]+(?=\()/i,number:/\b-?(?:0x[\da-f]+|\d*\.?\d+(?:e[+-]?\d+)?)\b/i,operator:/--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/,punctuation:/[{}[\];(),.:]/};
</script>

<script type="text/javascript">
Prism.languages.c=Prism.languages.extend("clike",{keyword:/\b(asm|typeof|inline|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while)\b/,operator:/\-[>-]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|?\||[~^%?*\/]/,number:/\b-?(?:0x[\da-f]+|\d*\.?\d+(?:e[+-]?\d+)?)[ful]*\b/i}),Prism.languages.insertBefore("c","string",{macro:{pattern:/(^\s*)#\s*[a-z]+([^\r\n\\]|\\.|\\(?:\r\n?|\n))*/im,lookbehind:!0,alias:"property",inside:{string:{pattern:/(#\s*include\s*)(<.+?>|("|')(\\?.)+?\3)/,lookbehind:!0},directive:{pattern:/(#\s*)\b(define|elif|else|endif|error|ifdef|ifndef|if|import|include|line|pragma|undef|using)\b/,lookbehind:!0,alias:"keyword"}}},constant:/\b(__FILE__|__LINE__|__DATE__|__TIME__|__TIMESTAMP__|__func__|EOF|NULL|stdin|stdout|stderr)\b/}),delete Prism.languages.c["class-name"],delete Prism.languages.c["boolean"];
</script>

<script type="text/javascript">
Prism.languages.cpp=Prism.languages.extend("c",{keyword:/\b(alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|class|compl|const|constexpr|const_cast|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|float|for|friend|goto|if|inline|int|long|mutable|namespace|new|noexcept|nullptr|operator|private|protected|public|register|reinterpret_cast|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/,"boolean":/\b(true|false)\b/,operator:/[-+]{1,2}|!=?|<{1,2}=?|>{1,2}=?|\->|:{1,2}|={1,2}|\^|~|%|&{1,2}|\|?\||\?|\*|\/|\b(and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/}),Prism.languages.insertBefore("cpp","keyword",{"class-name":{pattern:/(class\s+)[a-z0-9_]+/i,lookbehind:!0}});
</script>

<script type="text/javascript">
$('tblcode').replaceWith(function(){
    return $("<pre style=\"background:transparent;border:none\"><code class=\"language-cpp\">" + $(this).text() + "</code></pre>");
});
</script>
</head>
<body>
<address align=right>
Document number:  dXXXX
 <br />
Date: 2017-10-24 <br />
Audience:  EWG
 <br />
Reply-To:  Barry Revzin &lt;barry.revzin@gmail.com><br />
 Simon Brand &lt;simon@codeplay.com><br />
</address>
<hr/><h1 align=center> Deducing this
</h1>
<h2>Contents</h2>
<ol><li><a href="#toc_1">Motivation
</a></li><li><a href="#toc_2">Proposal
</a><ol><li><a href="#toc_2.1">Alternative syntax
</a></li></ol></li><li><a href="#toc_3">Examples
</a><ol><li><a href="#toc_3.1">Deduplicating Code
</a></li><li><a href="#toc_3.2">SFINAE-friendly callables
</a></li><li><a href="#toc_3.3">Recursive Lambdas
</a></li></ol></li></ol>
<a name="toc_1"></a><h2>1. Motivation
</h2>
<p><p>In C++03, member functions could have <em>cv</em>-qualifications, so it was possible to have scenarios where a particular class would want both a <code class="language-cpp">const</code> and non-<code class="language-cpp">const</code> overload of a particular member (Of course it was possible to also want <code class="language-cpp">volatile</code> overloads, but those are less common). In these cases, both overloads do the same thing - the only difference is in the types accessed and used. This was handled by either simply duplicating the function, adjusting types and qualifications as necessary, or having one delegate to the other. An example of the latter can be found in Scott Meyers' "Effective C++", Item 3:</p><pre ><code class="language-cpp">class TextBlock {
public:
  const char&amp; operator[](std::size_t position) const {
    // ...
    return text[position];
  }

  char&amp; operator[](std::size_t position) {
    return const_cast&lt;char&amp;&gt;(
      static_cast&lt;const TextBlock&amp;&gt;(this)[position]
    );
  }
  // ...
};
</code></pre>
<p><p>Neither the duplication or the delegation via <code class="language-cpp">const_cast</code> are arguably great solutions, but they work.</p><p><p>In C++11, member functions acquired a new axis to specialize on: ref-qualifiers. Now, instead of potentially needing two overloads of a single member function, we might need four: <code class="language-cpp">&amp;</code>, <code class="language-cpp">const&amp;</code>, <code class="language-cpp">&amp;&amp;</code>, or <code class="language-cpp">const&amp;&amp;</code>. We have three approaches to deal with this: we implement the same member four times, we can have three of the overloads delegate to the fourth, or we can have all four delegate to a helper, private static member function. One example might be the overload set for <code class="language-cpp">optional&lt;T&gt;::value()</code>. The way to implement it would be something like:</p><table style="width: 100%">
<p><tr><th>Quadruplication</th><th>Delegation to 4th</th><th>Delegation to helper</th></tr><p><tr><td><pre style="background:transparent;border:0px"><code class="language-cpp">template &lt;typename T&gt;
class optional {
    // ...
    constexpr T&amp; value() &amp; {
        if (has_value()) {
            return this-&gt;m_value;
        }
        throw bad_optional_access();
    }

    constexpr const T&amp; value() const&amp; {
        if (has_value()) {
            return this-&gt;m_value;
        }
        throw bad_optional_access();
    }

    constexpr T&amp;&amp; value() &amp;&amp; {
        if (has_value()) {
            return std::move(this-&gt;m_value);
        }
        throw bad_optional_access();
    }

    constexpr const T&amp;&amp;
    value() const&amp;&amp; {
        if (has_value()) {
            return std::move(this-&gt;m_value);
        }
        throw bad_optional_access();
    }
    // ...
};
</code></pre>
<p></td><p><td><pre style="background:transparent;border:0px"><code class="language-cpp">template &lt;typename T&gt;
class optional {
    // ...
    constexpr T&amp; value() &amp; {
        return const_cast&lt;T&amp;&gt;(
            static_cast&lt;optional const&amp;&gt;(
                *this).value());
    }

    constexpr const T&amp; value() const&amp; {
        if (has_value()) {
            return this-&gt;m_value;
        }
        throw bad_optional_access();
    }

    constexpr T&amp;&amp; value() &amp;&amp; {
        return const_cast&lt;T&amp;&amp;&gt;(
            static_cast&lt;optional const&amp;&gt;(
                *this).value());
    }

    constexpr const T&amp;&amp;
    value() const&amp;&amp; {
        return static_cast&lt;const T&amp;&amp;&gt;(
            value());
    }
    // ...
};
</code></pre>
<p></td><p><td><pre style="background:transparent;border:0px"><code class="language-cpp">template &lt;typename T&gt;
class optional {
    // ...
    constexpr T&amp; value() &amp; {
        return value_impl(*this);
    }

    constexpr const T&amp; value() const&amp; {
        return value_impl(*this);
    }

    constexpr T&amp;&amp; value() &amp;&amp; {
        return value_impl(std::move(*this));
    }

    constexpr const T&amp;&amp;
    value() const&amp;&amp; {
        return value_impl(std::move(*this));
    }

private:
    template &lt;typename Opt&gt;
    static decltype(auto)
    value_impl(Opt&amp;&amp; opt) {
        if (!opt.has_value()) {
            throw bad_optional_access();
        }
        return std::forward&lt;Opt&gt;(opt).m_value;
    }


    // ...
};
</code></pre>
<p><p></td></tr></p></table>
<p><p>It's not like this is a complicated function. Far from. But more or less repeating the same code four times, or artificial delegation to avoid doing so, is the kind of thing that begs for a rewrite. Except we can't really. We <em>have</em> to implement it this way. It seems like we should be able to abstract away the qualifiers. And we can... sort of. As a non-member function, we simply don't have this problem:</p><pre ><code class="language-cpp">template &lt;typename T&gt;
class optional {
    // ...
    template &lt;typename Opt&gt;
    friend decltype(auto) value(Opt&amp;&amp; o) {
        if (o.has_value()) {
            return std::forward&lt;Opt&gt;(o).m_value;
        }
        throw bad_optional_access();
    }
    // ...
};
</code></pre>
<p><p>This is great - it's just one function, that handles all four cases for us. Except it's a non-member function, not a member function. Different semantics, different syntax, doesn't help.</p><p><p>There are many, many cases in code-bases where we need two or four overloads of the same member function for different <code class="language-cpp">const</code>- or ref-qualifiers. More than that, there are likely many cases that a class should have four overloads of a particular member function, but doesn't simply due to laziness by the developer. We think that there are sufficiently many such cases that they merit a better solution than simply: write it, then write it again, then write it two more times.</p><a name="toc_2"></a><h2>2. Proposal
</h2>
<p><p>This paper proposes a new way of declaring a member function that will allow for deducing the type and value category of the class instance parameter, while still being invokable as a member function.</p><p><p>We propose allowing the first parameter of a member function to be named <code class="language-cpp">this</code>, with the following restrictions:</p><ul><li><p>The member function shall not have any <em>cv</em>- or ref-qualifiers</p></li><li><p>The member function shall not be <code class="language-cpp">static</code></p></li><li><p>The type of the <code class="language-cpp">this</code> parameter shall be either:</p></li><ul><li><p>a reference to possibly <em>cv</em>-qualified function template parameter</p></li><li><p>a reference to possibly <em>cv</em>-qualified <em>injected-class-name</em></p></li></ul></ul><p><p>The <code class="language-cpp">this</code> parameter will bind to the implicit object argument, as if it were passed as the first argument to a non-member function with the same signature. </p><pre ><code class="language-cpp">struct X {
    void foo(X&amp; this);

    template &lt;typename This&gt;
    void bar(This&amp;&amp; this, int i);
};

// X::foo is member function taking no arguments, X::bar takes one 
// argument of type int
X x;
x.foo();
x.bar(0);

// These behave as if the call were to these non-member functions
void foo(X&amp; obj);

template &lt;typename This&gt;
void bar(This&amp;&amp; obj, int i);
foo(x);
bar(x, 0);
</code></pre>
<p><p>The usual template deduction rules apply to the <code class="language-cpp">this</code> parameter. While the naming of the parameter <code class="language-cpp">this</code> is significant, the naming of the template type parameter as <code class="language-cpp">This</code> is not. It is used throughout merely a suggested convention.</p><pre ><code class="language-cpp">struct Y {
    template &lt;typename This, typename T&gt;
    void bar(This&amp;&amp; this, T&amp;&amp; );

    template &lt;typename Self&gt;
    void quux(Self&amp; this);
};

void demo(Y y, const Y* py) {
    y.bar(4);     // invokes Y::bar&lt;Y&amp;, int&gt;
    py-&gt;bar(2.0); // invokes Y::bar&lt;const Y&amp;, double&gt;

    Y{}.quux();   // ill-formed
    y.quux();     // invokes Y::quux&lt;Y&gt;
    py-&gt;quux();   // invokes Y::quux&lt;const Y&gt;
}
</code></pre>
<p><p>It will be possible to take pointers to these member functions. Their types would be qualified based on the deduced qualification of the instance object. That is, <code class="language-cpp">decltype(&amp;Y::bar&lt;Y, int&gt;)</code> is <code class="language-cpp">void (Y::*)(int) &amp;&amp;</code> and <code class="language-cpp">decltype(&amp;Y::quux&lt;const Y&gt;)</code> is <code class="language-cpp">void (Y::*)() const&amp;</code>. These member functions can be invoked via pointers to members as usual. </p><p><p>While the type of the <code class="language-cpp">this</code> parameter is deduced, it will always be some qualified form of the class type in which the member function is declared, never a derived type:</p><pre ><code class="language-cpp">struct B {
    template &lt;typename This&gt;
    void do_stuff(This&amp;&amp; this);
};

struct D : B { };

D d;
d.do_stuff();  // invokes B::do_stuff&lt;B&amp;&gt;, not B::do_stuff&lt;D&amp;&gt;
</code></pre>
<p><p>Within these member functions, the keyword <code class="language-cpp">this</code> will be used as a reference, not as a pointer. While inconsistent with usage in normal member functions, it is more consistent with its declaration as a parameter of reference type and its ability to be deduced as a forwarding reference. This difference will be a signal to users that this is a different kind of member function, additionally obviating any questions about checking against <code class="language-cpp">nullptr</code>. </p><p><p>Accessing members would be done via <code class="language-cpp">this.mem</code> and not <code class="language-cpp">this-&gt;mem</code>. There is no implicit <code class="language-cpp">this</code> object, since we now have an <em>explicit</em> instance parameter, so all member access must be qualified:</p><pre ><code class="language-cpp">template &lt;typename T&gt;
class Z {
    T value;
public:
    template &lt;typename Object&gt;
    decltype(auto) get(Object&amp;&amp; this) {
        return value; // error: unknown identifier 'value'
        return std::forward&lt;Object&gt;(this).value; // ok
    }
};
</code></pre>
<p><p>The only allowed types for the <code class="language-cpp">this</code> parameter are reference to function template parameter and reference to <em>injected-class-name</em>. We do not expect the latter form to be used very often, but likewise we see no reason to artificially limit the proposal to templates.</p><pre ><code class="language-cpp">template &lt;typename T&gt;
struct B {
    template &lt;typename This&gt;
    void a(This&amp;&amp; this);      // ok

    void b(B&amp; this);          // ok
    template &lt;typename This&gt;
    void c(const This&amp; this); // ok

    void d(B this);           // error: not a reference type
    void e(B* this);          // error: not a reference type
    void f(B&lt;T&gt;&amp; this);       // error: not injected-class-name
    template &lt;typename U&gt;
    void g(B&lt;U*&gt;&amp; this);      // error: not reference to template-parameter
    void h(T&amp; this);          // error: not reference to function's template-parameter
};
</code></pre>
<p><p>Since in many ways member functions act as if they accepted an instance of class type as their first parameter (for instance, in <code class="language-cpp">INVOKE</code> and all the functional objects that rely on this), we believe this is a logical extension of the language rules to solve a common and growing source of frustration. This sort of code deduplication is, after all, precisely what templates are for.</p><p><p>Overload resolution between new-style and old-style member functions would compare the explicit this parameter of the new functions with the implicit this parameter of the old functions:</p><pre ><code class="language-cpp">struct C {
    template &lt;typename This&gt;
    void foo(This&amp; this); // #1
    void foo() const;     // #2
};

void demo(C* c, C const* d) {
    c-&gt;foo(); // calls #1, better match
    d-&gt;foo(); // calls #2, non-template preferred to template
}
</code></pre>
<p><p>As <code class="language-cpp">this</code> cannot be used as a parameter name today, this proposal is purely a language extension. All current syntax remains valid.</p><a name="toc_2.1"></a><h3>2.1. Alternative syntax
</h3>
<p><p>Rather than naming the first parameter <code class="language-cpp">this</code>, we can also consider introducing a dummy template parameter where the qualifications normally reside. This syntax is also ill-formed today, and is purely a language extension:</p><pre ><code class="language-cpp">template &lt;typename T&gt;
struct X {
    T value;

    // as proposed
    template &lt;typename This&gt;
    decltype(auto) foo(This&amp;&amp; this) {
        return std::forward&lt;This&gt;(this).value;
    }

    // alternative
    template &lt;typename This&gt;
    decltype(auto) foo() This&amp;&amp; {
        return std::forward&lt;This&gt;(*this).value;
    }
};
</code></pre>
<a name="toc_3"></a><h2>3. Examples
</h2>
<a name="toc_3.1"></a><h3>3.1. Deduplicating Code
</h3>
<p><p>This proposal can de-duplicate and de-quadruplicate a large amount of code. In each case, the single function is only slightly more complex than the initial two or four, which makes for a huge win. What follows are a few examples of how repeated code can be reduced.</p><p><p>The particular implementation of optional is Simon's, and can be viewed on <a href="https://github.com/TartanLlama/optional">GitHub</a>, and this example includes some functions that are proposed in <a href="https://wg21.link/p0798">[P0798]</a>, with minor changes to better suit this format:</p><table style="width: 100%">
<p><tr><th>C++17</th><th>This proposal</th></tr><p><tr><p><td><pre style="background:transparent;border:0px"><code class="language-cpp">class TextBlock {
public:
  const char&amp;
  operator[](std::size_t position) const {
    // ...
    return text[position];
  }

  char&amp; operator[](std::size_t position) {
    return const_cast&lt;char&amp;&gt;(
      static_cast&lt;const TextBlock&amp;&gt;
        (this)[position]
    );
  }
  // ...
};
</code></pre>
<p><td><pre style="background:transparent;border:0px"><code class="language-cpp">class TextBlock {
public:
  template &lt;typename This&gt;
  auto&amp; operator[](This&amp; this,
                   std::size_t position) {
    // ...
    return this.text[position];
  }
  // ...
};
</code></pre>
<p></td><p></tr><p><tr><p><td><pre style="background:transparent;border:0px"><code class="language-cpp">template &lt;typename T&gt;
class optional {
  // ...
  constexpr T* operator-&gt;() {
    return std::addressof(this-&gt;m_value);
  }

  constexpr const T*
  operator-&gt;() const {
    return std::addressof(this-&gt;m_value);
  }
  // ...
};
</code></pre>
<p></td><p><td><pre style="background:transparent;border:0px"><code class="language-cpp">template &lt;typename T&gt;
class optional {
  // ...
  template &lt;typename This&gt;
  constexpr auto operator-&gt;(This&amp; this) {
    return std::addressof(this.m_value);
  }
  // ...
};
</code></pre>
<p></td><p></tr><p><tr><p><td><pre style="background:transparent;border:0px"><code class="language-cpp">template &lt;typename T&gt;
class optional {
  // ...
  constexpr T&amp; operator*() &amp; {
    return this-&gt;m_value;
  }

  constexpr const T&amp; operator*() const&amp; {
    return this-&gt;m_value;
  }

  constexpr T&amp;&amp; operator*() &amp;&amp; {
    return std::move(this-&gt;m_value);
  }

  constexpr const T&amp;&amp;
  operator*() const&amp;&amp; {
    return std::move(this-&gt;m_value);
  }

  constexpr T&amp; value() &amp; {
    if (has_value()) {
      return this-&gt;m_value;
    }
    throw bad_optional_access();
  }

  constexpr const T&amp; value() const&amp; {
    if (has_value()) {
      return this-&gt;m_value;
    }
    throw bad_optional_access();
  }

  constexpr T&amp;&amp; value() &amp;&amp; {
    if (has_value()) {
      return std::move(this-&gt;m_value);
    }
    throw bad_optional_access();
  }

  constexpr const T&amp;&amp; value() const&amp;&amp; {
    if (has_value()) {
      return std::move(this-&gt;m_value);
    }
    throw bad_optional_access();
  }
  // ...
};
</code></pre>
<p></td><p><td><pre style="background:transparent;border:0px"><code class="language-cpp">template &lt;typename T&gt;
class optional {
  // ...
  template &lt;typename This&gt;
  constexpr auto&amp;&amp; operator*(This&amp;&amp; this) {
    return forward&lt;This&gt;(this).m_value;
  }

  template &lt;typename This&gt;
  constexpr auto&amp;&amp; value(This&amp;&amp; this) {
    if (this.has_value()) {
      return forward&lt;This&gt;(this).m_value;
    }
    throw bad_optional_access();
  }
  // ...
};
</code></pre>
<p></td><p><tr><p><td><pre style="background:transparent;border:0px"><code class="language-cpp">template &lt;typename T&gt;
class optional {
  // ...
  template &lt;typename F&gt;
  constexpr auto and_then(F&amp;&amp; f) &amp; {
    using result =
      invoke_result_t&lt;F, T&amp;&gt;;
    static_assert(
      is_optional&lt;result&gt;::value,
      "F must return an optional");

    return has_value()
        ? invoke(forward&lt;F&gt;(f), **this)
        : nullopt;
  }

  template &lt;typename F&gt;
  constexpr auto and_then(F&amp;&amp; f) &amp;&amp; {
    using result =
      invoke_result_t&lt;F, T&amp;&amp;&gt;;
    static_assert(
      is_optional&lt;result&gt;::value,
      "F must return an optional");

    return has_value()
        ? invoke(forward&lt;F&gt;(f),
                 std::move(**this))
        : nullopt;
  }

  template &lt;typename F&gt;
  constexpr auto and_then(F&amp;&amp; f) const&amp; {
    using result =
      invoke_result_t&lt;F, const T&amp;&gt;;
    static_assert(
      is_optional&lt;result&gt;::value,
      "F must return an optional");

    return has_value()
        ? invoke(forward&lt;F&gt;(f), **this)
        : nullopt;
  }

  template &lt;typename F&gt;
  constexpr auto and_then(F&amp;&amp; f) const&amp;&amp; {
    using result =
      invoke_result_t&lt;F, const T&amp;&amp;&gt;;
    static_assert(
      is_optional&lt;result&gt;::value,
      "F must return an optional");

    return has_value()
        ? invoke(forward&lt;F&gt;(f),
                 std::move(**this))
        : nullopt;
  }
  // ...
};
</code></pre>
<p></td><p><td><pre style="background:transparent;border:0px"><code class="language-cpp">template &lt;typename T&gt;
class optional {
  // ...
  template &lt;typename This, typename F&gt;
  constexpr auto
  and_then(This&amp;&amp; this, F&amp;&amp; f) &amp; {
    using val = decltype((
        forward&lt;This&gt;(this).m_value));
    using result = invoke_result_t&lt;F, val&gt;;

    static_assert(
      is_optional&lt;result&gt;::value,
      "F must return an optional");

    return this.has_value()
        ? invoke(forward&lt;F&gt;(f),
                 forward&lt;This&gt;
                   (this).m_value)
        : nullopt;
  }
  // ...
};
</code></pre>
<p></td></table>
<p><p>Keep in mind that there are a few more functions in P0798 that have this lead to this explosion of overloads, so the code difference and clarity is dramatic.</p><p><p>For those that dislike returning auto in these cases, it is very easy to write a metafunction that matches the appropriate qualifiers from a type. Certainly simpler than copying and pasting code and hoping that the minor changes were made correctly in every case.</p><a name="toc_3.2"></a><h3>3.2. SFINAE-friendly callables
</h3>
<p><p>A seemingly unrelated problem to the question of code quadruplication is that of writing these numerous overloads for function wrappers, as demonstrated in <a href="https://wg21.link/p0826">[P0826]</a>. Consider what happens if we implement <code class="language-cpp">std::not_fn()</code>, as currently specified:</p><pre ><code class="language-cpp">template &lt;typename F&gt;
class call_wrapper {
    F f;
public:
    // ...
    template &lt;typename... Args&gt;
    auto operator()(Args&amp;&amp;... ) &amp;
        -&gt; decltype(!declval&lt;invoke_result_t&lt;F&amp;, Args...&gt;&gt;())'

    template &lt;typename... Args&gt;
    auto operator()(Args&amp;&amp;... ) const&amp;
        -&gt; decltype(!declval&lt;invoke_result_t&lt;const F&amp;, Args...&gt;&gt;());

    // ... same for &amp;&amp; and const &amp;&amp; ...
};

template &lt;typename F&gt;
auto not_fn(F&amp;&amp; f) {
    return call_wrapper&lt;std::decay_t&lt;F&gt;&gt;{std::forward&lt;F&gt;(f)};
}
</code></pre>
<p><p>As described in the paper, this implementation has two pathological cases: one in which the callable is SFINAE-unfriendly (which would cause a call to be ill-formed, when it could otherwise work), and one in which overload is deleted (which would cause a call to fallback to a different overload, when it should fail):</p><pre ><code class="language-cpp">struct unfriendly {
    template &lt;typename T&gt;
    auto operator()(T v) {
        static_assert(std::is_same_v&lt;T, int&gt;);
        return v;
    }

    template &lt;typename T&gt;
    auto operator()(T v) const {
        static_assert(std::is_same_v&lt;T, double&gt;);
        return v;
    }
};

struct fun {
    template &lt;typename... Args&gt;
    void operator()(Args&amp;&amp;...) = delete;

    template &lt;typename... Args&gt;
    bool operator()(Args&amp;&amp;...) const { return true; }
};

std::not_fn(unfriendly{})(1); // static assert!
std::not_fn(fun{})();         // ok!? Returns false
</code></pre>
<p><p>Gracefully handling SFINAE-unfriendly callables is <strong>not solvable</strong> in C++ today. Preventing fallback can be solved by the addition of yet another four overloads, so that each of the four <em>cv</em>/ref-qualifiers leads to a pair of overloads: one enabled and one <code class="language-cpp">deleted</code>.</p><p><p>This proposal solves both problems by simply allowing <code class="language-cpp">this</code> to be deduced. The following is a complete implementation of <code class="language-cpp">std::not_fn</code>:</p><pre ><code class="language-cpp">template &lt;typename F&gt;
struct call_wrapper {
    F f;

    template &lt;typename This, typename... Args&gt;
    auto operator()(This&amp;&amp; this, Args&amp;&amp;... )
        -&gt; decltype(!invoke(forward&lt;This&gt;(this).f, forward&lt;Args&gt;(args)...))
    {
        return !invoke(forward&lt;This&gt;(this).f, forward&lt;Args&gt;(args)...);
    }
};

template &lt;typename F&gt;
auto not_fn(F&amp;&amp; f) {
    return call_wrapper&lt;std::decay_t&lt;F&gt;&gt;{std::forward&lt;F&gt;(f)};
}

not_fn(unfriendly{})(1); // ok
not_fn(fun{})();         // error
</code></pre>
<p><p>Here, there is only one overload with everything deduced together, with either <code class="language-cpp">This = fun</code> or <code class="language-cpp">This = poison</code> as appropriate. As a result, this singular overload then has precisely the desired behavior: working, for <code class="language-cpp">unfriendly</code>, and not working, for <code class="language-cpp">fun</code>.</p><a name="toc_3.3"></a><h3>3.3. Recursive Lambdas
</h3>
<p><p>This proposal also allows for an alternative solution to implementing a recursive lambda, since now we open up the possibility of allowing a lambda to reference itself:</p><pre ><code class="language-cpp">// as proposed in [P0839]
auto fib = [] self (int n) {
    if (n &lt; 2) return n;
    return self(n-1) + self(n-2);
};

// this proposal
auto fib = [](auto&amp; this, int n) {
    if (n &lt; 2) return n;
    return this(n-1) + this(n-2);
};
</code></pre>
<p><p>In the specific case of lambdas, a lambda could both capture <code class="language-cpp">this</code> and take a generic parameter named <code class="language-cpp">this</code>. If this happens, use of <code class="language-cpp">this</code> would refer to the parameter (and hence, the lambda itself) and not the <code class="language-cpp">this</code> pointer of the outer-most class. This preference follows the normal scoping rules.</p><pre ><code class="language-cpp">struct A {
    int bar();

    auto foo() {
        return [this](auto&amp; this, int n) {
            return this-&gt;bar() + n; // error: no operator-&gt;() for this lambda
        };
    }
};
</code></pre>

</body>
</html>
